import argparse
import base64
import getpass
import os
import shlex
import struct
import sys
from datetime import datetime
from pathlib import Path

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt


MAGIC_V1 = b"AES256CLI1"
MAGIC_V2 = b"AESRSA4096V2"
MAGIC_V3 = b"AES256SC3"
MAGIC_V4 = b"AESRSAPEM4"

SALT_SIZE = 16
NONCE_SIZE = 12
KEY_SIZE = 32  # 32 bytes = AES-256

PBKDF2_ITERATIONS_V1 = 390_000
PBKDF2_ITERATIONS_V2 = 600_000
RSA4096_ENCRYPTED_KEY_SIZE = 512

SCRYPT_N = 1 << 15
SCRYPT_R = 8
SCRYPT_P = 1


BANNER = r"""
                                        _    _____ ____ ____  ____   __   
                                       / \  | ____/ ___|___ \| ___| / /_  
                                      / _ \ |  _| \___ \ __) |___ \| '_ \ 
                                     / ___ \| |___ ___) / __/ ___) | (_) |
                                    /_/   \_\_____|____/_____|____/ \___/ 
                                       
"""


HELP_EXAMPLES = r"""Examples:
  help
  generate-keypair
  encrypt-text -t "hello world" -p "your-strong-password"
  encrypt-text -t "hello world" -p password.txt
  decrypt-text -t "<TOKEN>" -p "your-strong-password"
  decrypt-text -t "<TOKEN>" -p password.txt

  # Public/Private key (RSA PEM) mode
  encrypt-text-pem -t "hello world" --public-key public_key.pem
  decrypt-text-pem -t "<TOKEN>" --private-key private_key.pem

  # Password-based file mode (.txt only)
  encrypt-file -i notes.txt -p "your-strong-password"
  encrypt-file -i notes.txt -p password.txt
  decrypt-file -i notes.aes -o notes.dec.txt -p "your-strong-password"
  decrypt-file -i notes.aes -o notes.dec.txt -p password.txt

  # Password-based file mode (raw binary payload)
  encrypt-file -i notes.txt -p password.txt --raw -o notes.aesbin
  decrypt-file -i notes.aesbin -p password.txt -o notes.dec.txt

  # PEM file mode (hybrid RSA+AES)
  encrypt-file-pem -i notes.txt --public-key public_key.pem
  decrypt-file-pem -i notes_pem.aes --private-key private_key.pem -o notes.dec.txt

  # PEM file mode (raw binary payload)
  encrypt-file-pem -i notes.txt --public-key public_key.pem --raw -o notes_pem.aesbin
  decrypt-file-pem -i notes_pem.aesbin --private-key private_key.pem --raw -o notes.dec.txt"""


def print_banner():
    print(BANNER)


def help_flow(args):
    args.parser.print_help()


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


def print_dashboard(last_result: str):
    print(BANNER)
    print(
        "Commands: help | encrypt-text | decrypt-text | encrypt-file | decrypt-file | "
        "generate-keypair | encrypt-text-pem | decrypt-text-pem | encrypt-file-pem | decrypt-file-pem"
    )
    if last_result:
        print(last_result.strip())


def derive_key_pbkdf2(password: str, salt: bytes, algorithm: hashes.HashAlgorithm, iterations: int) -> bytes:
    kdf = PBKDF2HMAC(
        algorithm=algorithm,
        length=KEY_SIZE,
        salt=salt,
        iterations=iterations,
    )
    return kdf.derive(password.encode("utf-8"))


def derive_key_v1(password: str, salt: bytes) -> bytes:
    return derive_key_pbkdf2(password, salt, hashes.SHA256(), PBKDF2_ITERATIONS_V1)


def derive_key_v2(password: str, salt: bytes) -> bytes:
    return derive_key_pbkdf2(password, salt, hashes.SHA512(), PBKDF2_ITERATIONS_V2)


def derive_key_v3(password: str, salt: bytes) -> bytes:
    kdf = Scrypt(
        salt=salt,
        length=KEY_SIZE,
        n=SCRYPT_N,
        r=SCRYPT_R,
        p=SCRYPT_P,
    )
    return kdf.derive(password.encode("utf-8"))


def pack_payload_v1(salt: bytes, nonce: bytes, ciphertext: bytes) -> bytes:
    return MAGIC_V1 + salt + nonce + ciphertext


def unpack_payload_v1(payload: bytes):
    if len(payload) < len(MAGIC_V1) + SALT_SIZE + NONCE_SIZE + 16:
        raise ValueError("Encrypted payload is too short or malformed.")
    if not payload.startswith(MAGIC_V1):
        raise ValueError("Invalid payload header. Not generated by this CLI.")

    offset = len(MAGIC_V1)
    salt = payload[offset : offset + SALT_SIZE]
    offset += SALT_SIZE
    nonce = payload[offset : offset + NONCE_SIZE]
    offset += NONCE_SIZE
    ciphertext = payload[offset:]
    return salt, nonce, ciphertext


def unpack_payload_v2(payload: bytes):
    header_size = len(MAGIC_V2) + SALT_SIZE + NONCE_SIZE + NONCE_SIZE + 4 + 2
    if len(payload) < header_size + 16:
        raise ValueError("Encrypted payload is too short or malformed.")
    if not payload.startswith(MAGIC_V2):
        raise ValueError("Invalid payload header. Not generated by this CLI.")

    offset = len(MAGIC_V2)
    salt = payload[offset : offset + SALT_SIZE]
    offset += SALT_SIZE
    key_nonce = payload[offset : offset + NONCE_SIZE]
    offset += NONCE_SIZE
    data_nonce = payload[offset : offset + NONCE_SIZE]
    offset += NONCE_SIZE

    encrypted_private_key_len = struct.unpack(">I", payload[offset : offset + 4])[0]
    offset += 4
    encrypted_session_key_len = struct.unpack(">H", payload[offset : offset + 2])[0]
    offset += 2

    if encrypted_private_key_len <= 16:
        raise ValueError("Malformed payload: invalid private key section length.")
    if encrypted_session_key_len != RSA4096_ENCRYPTED_KEY_SIZE:
        raise ValueError("Malformed payload: invalid RSA section length.")
    if len(payload) < offset + encrypted_private_key_len + encrypted_session_key_len + 16:
        raise ValueError("Malformed payload: payload sections do not match declared lengths.")

    encrypted_private_key = payload[offset : offset + encrypted_private_key_len]
    offset += encrypted_private_key_len
    encrypted_session_key = payload[offset : offset + encrypted_session_key_len]
    offset += encrypted_session_key_len
    ciphertext = payload[offset:]

    if len(ciphertext) < 16:
        raise ValueError("Malformed payload: missing ciphertext/tag.")

    return salt, key_nonce, data_nonce, encrypted_private_key, encrypted_session_key, ciphertext


def pack_payload_v3(salt: bytes, nonce: bytes, ciphertext: bytes) -> bytes:
    return MAGIC_V3 + salt + nonce + ciphertext


def unpack_payload_v3(payload: bytes):
    if len(payload) < len(MAGIC_V3) + SALT_SIZE + NONCE_SIZE + 16:
        raise ValueError("Encrypted payload is too short or malformed.")
    if not payload.startswith(MAGIC_V3):
        raise ValueError("Invalid payload header. Not generated by this CLI.")

    offset = len(MAGIC_V3)
    salt = payload[offset : offset + SALT_SIZE]
    offset += SALT_SIZE
    nonce = payload[offset : offset + NONCE_SIZE]
    offset += NONCE_SIZE
    ciphertext = payload[offset:]
    return salt, nonce, ciphertext


def pack_payload_v4(nonce: bytes, encrypted_session_key: bytes, ciphertext: bytes) -> bytes:
    return MAGIC_V4 + nonce + struct.pack(">H", len(encrypted_session_key)) + encrypted_session_key + ciphertext


def unpack_payload_v4(payload: bytes):
    header_size = len(MAGIC_V4) + NONCE_SIZE + 2
    if len(payload) < header_size + 16:
        raise ValueError("Encrypted payload is too short or malformed.")
    if not payload.startswith(MAGIC_V4):
        raise ValueError("Invalid payload header. Not generated by this CLI.")

    offset = len(MAGIC_V4)
    nonce = payload[offset : offset + NONCE_SIZE]
    offset += NONCE_SIZE

    encrypted_session_key_len = struct.unpack(">H", payload[offset : offset + 2])[0]
    offset += 2
    if encrypted_session_key_len <= 0:
        raise ValueError("Malformed payload: invalid RSA section length.")
    if len(payload) < offset + encrypted_session_key_len + 16:
        raise ValueError("Malformed payload: payload sections do not match declared lengths.")

    encrypted_session_key = payload[offset : offset + encrypted_session_key_len]
    offset += encrypted_session_key_len
    ciphertext = payload[offset:]
    return nonce, encrypted_session_key, ciphertext


def encode_payload(payload: bytes) -> str:
    # Output stays ASCII (URL-safe Base64 without padding)
    return base64.urlsafe_b64encode(payload).decode("ascii").rstrip("=")


def decode_payload(token: str) -> bytes:
    token = token.strip()
    if not token:
        raise ValueError("Empty encrypted token.")

    missing_padding = len(token) % 4
    if missing_padding:
        token += "=" * (4 - missing_padding)

    try:
        return base64.urlsafe_b64decode(token.encode("ascii"))
    except Exception as exc:
        raise ValueError("Invalid base64 token.") from exc


def encrypt_bytes_v1(data: bytes, password: str) -> bytes:
    salt = os.urandom(SALT_SIZE)
    nonce = os.urandom(NONCE_SIZE)
    key = derive_key_v1(password, salt)
    ciphertext = AESGCM(key).encrypt(nonce, data, MAGIC_V1)
    return pack_payload_v1(salt, nonce, ciphertext)


def decrypt_bytes_v1(payload: bytes, password: str) -> bytes:
    salt, nonce, ciphertext = unpack_payload_v1(payload)
    key = derive_key_v1(password, salt)
    try:
        return AESGCM(key).decrypt(nonce, ciphertext, MAGIC_V1)
    except InvalidTag as exc:
        raise ValueError("Decryption failed: wrong password or corrupted data.") from exc


def decrypt_bytes_v2(payload: bytes, password: str) -> bytes:
    salt, key_nonce, data_nonce, encrypted_private_key, encrypted_session_key, ciphertext = unpack_payload_v2(payload)
    password_key = derive_key_v2(password, salt)

    try:
        private_key_pem = AESGCM(password_key).decrypt(key_nonce, encrypted_private_key, None)
    except InvalidTag as exc:
        raise ValueError("Decryption failed: wrong password or corrupted data.") from exc

    try:
        private_key = serialization.load_pem_private_key(private_key_pem, password=None)
        session_key = private_key.decrypt(
            encrypted_session_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA512()),
                algorithm=hashes.SHA512(),
                label=None,
            ),
        )
        return AESGCM(session_key).decrypt(data_nonce, ciphertext, None)
    except Exception as exc:
        raise ValueError("Decryption failed: wrong password or corrupted data.") from exc


def encrypt_bytes_v3(data: bytes, password: str) -> bytes:
    salt = os.urandom(SALT_SIZE)
    nonce = os.urandom(NONCE_SIZE)
    key = derive_key_v3(password, salt)
    ciphertext = AESGCM(key).encrypt(nonce, data, MAGIC_V3)
    return pack_payload_v3(salt, nonce, ciphertext)


def decrypt_bytes_v3(payload: bytes, password: str) -> bytes:
    salt, nonce, ciphertext = unpack_payload_v3(payload)
    key = derive_key_v3(password, salt)
    try:
        return AESGCM(key).decrypt(nonce, ciphertext, MAGIC_V3)
    except InvalidTag as exc:
        raise ValueError("Decryption failed: wrong password or corrupted data.") from exc


def encrypt_bytes_v4(data: bytes, public_key: rsa.RSAPublicKey) -> bytes:
    session_key = os.urandom(KEY_SIZE)
    nonce = os.urandom(NONCE_SIZE)
    ciphertext = AESGCM(session_key).encrypt(nonce, data, MAGIC_V4)
    encrypted_session_key = public_key.encrypt(
        session_key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None,
        ),
    )
    return pack_payload_v4(nonce, encrypted_session_key, ciphertext)


def decrypt_bytes_v4(payload: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
    nonce, encrypted_session_key, ciphertext = unpack_payload_v4(payload)
    try:
        session_key = private_key.decrypt(
            encrypted_session_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None,
            ),
        )
        return AESGCM(session_key).decrypt(nonce, ciphertext, MAGIC_V4)
    except Exception as exc:
        raise ValueError("Decryption failed: wrong private key or corrupted data.") from exc


def encrypt_bytes(data: bytes, password: str) -> bytes:
    return encrypt_bytes_v3(data, password)


def decrypt_bytes(payload: bytes, password: str) -> bytes:
    if payload.startswith(MAGIC_V3):
        return decrypt_bytes_v3(payload, password)
    if payload.startswith(MAGIC_V2):
        return decrypt_bytes_v2(payload, password)
    if payload.startswith(MAGIC_V1):
        return decrypt_bytes_v1(payload, password)
    raise ValueError("Invalid payload header. Not generated by this CLI.")


def read_password_from_file(password_path: Path) -> str:
    if not password_path.exists():
        raise FileNotFoundError(f"Password file not found: {password_path}")
    if not password_path.is_file():
        raise ValueError(f"Password path is not a file: {password_path}")

    content = password_path.read_text(encoding="utf-8")
    if "\x00" in content:
        raise ValueError(f"Password file contains invalid NULL byte: {password_path}")

    password = content.rstrip("\r\n")
    if "\n" in password or "\r" in password:
        raise ValueError(f"Password file must contain a single-line password: {password_path}")
    if not password:
        raise ValueError(f"Password file is empty: {password_path}")
    return password


def resolve_password_arg(password_arg: str) -> str:
    password_path = Path(password_arg).expanduser()
    if password_path.suffix.lower() == ".txt":
        return read_password_from_file(password_path.resolve())
    return password_arg


def resolve_key_path(path_arg: str) -> Path:
    return Path(path_arg).expanduser().resolve()


def make_forced_timestamped_key_path(path_arg: str | None, default_prefix: str, timestamp: str) -> Path:
    if path_arg:
        raw_path = Path(path_arg).expanduser()
        parent = raw_path.parent
        stem = raw_path.stem if raw_path.suffix else raw_path.name
        suffix = raw_path.suffix if raw_path.suffix else ".pem"
    else:
        parent = Path(".")
        stem = default_prefix
        suffix = ".pem"

    return (parent / f"{stem}_{timestamp}{suffix}").resolve()


def parse_private_pass_arg(private_pass_arg: str | None) -> bytes | None:
    if private_pass_arg is None:
        return None

    password = resolve_password_arg(private_pass_arg)
    if not password:
        raise ValueError("Private key password cannot be empty.")
    return password.encode("utf-8")


def load_public_key_pem(path_arg: str) -> rsa.RSAPublicKey:
    path = resolve_key_path(path_arg)
    if not path.exists():
        raise FileNotFoundError(f"Public key file not found: {path}")
    if not path.is_file():
        raise ValueError(f"Public key path is not a file: {path}")

    key_data = path.read_bytes()
    try:
        public_key = serialization.load_pem_public_key(key_data)
    except Exception as exc:
        raise ValueError(f"Failed to load PEM public key: {path}") from exc

    if not isinstance(public_key, rsa.RSAPublicKey):
        raise ValueError("Public key must be an RSA PEM key.")
    return public_key


def load_private_key_pem(path_arg: str, private_pass_arg: str | None) -> rsa.RSAPrivateKey:
    path = resolve_key_path(path_arg)
    if not path.exists():
        raise FileNotFoundError(f"Private key file not found: {path}")
    if not path.is_file():
        raise ValueError(f"Private key path is not a file: {path}")

    key_data = path.read_bytes()
    password_bytes = parse_private_pass_arg(private_pass_arg)

    try:
        private_key = serialization.load_pem_private_key(key_data, password=password_bytes)
    except Exception as exc:
        if password_bytes is None and b"ENCRYPTED" in key_data:
            password = getpass.getpass("Private key password: ")
            if not password:
                raise ValueError("Private key password cannot be empty.")
            try:
                private_key = serialization.load_pem_private_key(key_data, password=password.encode("utf-8"))
            except Exception as inner_exc:
                raise ValueError("Failed to load private key: wrong password or malformed PEM.") from inner_exc
        else:
            raise ValueError("Failed to load private key: wrong password or malformed PEM.") from exc

    if not isinstance(private_key, rsa.RSAPrivateKey):
        raise ValueError("Private key must be an RSA PEM key.")
    return private_key


def build_private_encryption(private_pass_arg: str | None, encrypt_private: bool):
    if private_pass_arg:
        private_password = resolve_password_arg(private_pass_arg)
    elif encrypt_private:
        private_password = get_password(None, confirm=True)
    else:
        private_password = None

    if private_password:
        return serialization.BestAvailableEncryption(private_password.encode("utf-8"))
    return serialization.NoEncryption()


def get_password(password_arg: str | None, confirm: bool = False) -> str:
    if password_arg:
        password = resolve_password_arg(password_arg)
        if not password:
            raise ValueError("Password cannot be empty.")
        return password

    password = getpass.getpass("Password: ")
    if not password:
        raise ValueError("Password cannot be empty.")

    if confirm:
        confirm_password = getpass.getpass("Confirm password: ")
        if password != confirm_password:
            raise ValueError("Passwords do not match.")
    return password


def generate_keypair_flow(args):
    timestamp = datetime.now().strftime("%d%m%Y_%H%M%S")
    private_path = make_forced_timestamped_key_path(args.private_out, "private_key", timestamp)
    public_path = make_forced_timestamped_key_path(args.public_out, "public_key", timestamp)
    if private_path == public_path:
        raise ValueError("Private and public key output paths must be different.")

    if private_path.exists() and not args.force:
        raise FileExistsError(f"Private key output already exists: {private_path}. Use --force to overwrite.")
    if public_path.exists() and not args.force:
        raise FileExistsError(f"Public key output already exists: {public_path}. Use --force to overwrite.")
    if private_path.exists() and private_path.is_dir():
        raise ValueError(f"Private key output path is a directory: {private_path}")
    if public_path.exists() and public_path.is_dir():
        raise ValueError(f"Public key output path is a directory: {public_path}")

    private_path.parent.mkdir(parents=True, exist_ok=True)
    public_path.parent.mkdir(parents=True, exist_ok=True)

    private_key = rsa.generate_private_key(public_exponent=65537, key_size=args.bits)
    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=build_private_encryption(args.private_pass, args.encrypt_private),
    )
    public_pem = private_key.public_key().public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    private_path.write_bytes(private_pem)
    public_path.write_bytes(public_pem)

    print(f"\n[OK] Private key saved: {private_path}")
    print(f"[OK] Public key saved:  {public_path}")


def encrypt_text_flow(args):
    text = args.text
    if text is None:
        text = input("Text to encrypt: ")
    if not text:
        raise ValueError("Text cannot be empty.")

    password = get_password(args.password, confirm=True)
    encrypted = encrypt_bytes(text.encode("utf-8"), password)
    token = encode_payload(encrypted)

    print("\n[OK] Encrypted token:")
    print(token)


def decrypt_text_flow(args):
    token = args.token
    if token is None:
        token = input("Token to decrypt: ")

    password = get_password(args.password, confirm=False)
    payload = decode_payload(token)
    plaintext = decrypt_bytes(payload, password)

    try:
        text = plaintext.decode("utf-8")
    except UnicodeDecodeError as exc:
        raise ValueError("Decrypted bytes are not valid UTF-8 text.") from exc

    print("\n[OK] Decrypted text:")
    print(text)


def encrypt_text_pem_flow(args):
    text = args.text
    if text is None:
        text = input("Text to encrypt: ")
    if not text:
        raise ValueError("Text cannot be empty.")

    public_key = load_public_key_pem(args.public_key)
    encrypted = encrypt_bytes_v4(text.encode("utf-8"), public_key)
    token = encode_payload(encrypted)

    print("\n[OK] Encrypted token:")
    print(token)


def decrypt_text_pem_flow(args):
    token = args.token
    if token is None:
        token = input("Token to decrypt: ")

    private_key = load_private_key_pem(args.private_key, args.private_pass)
    payload = decode_payload(token)
    plaintext = decrypt_bytes_v4(payload, private_key)

    try:
        text = plaintext.decode("utf-8")
    except UnicodeDecodeError as exc:
        raise ValueError("Decrypted bytes are not valid UTF-8 text.") from exc

    print("\n[OK] Decrypted text:")
    print(text)


def encrypt_file_flow(args):
    input_path = Path(args.input).resolve()
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")
    if input_path.suffix.lower() != ".txt":
        raise ValueError("Only .txt files are allowed for file encryption.")

    # default outputs:
    # - token mode: <stem>.aes (text file storing base64 token)
    # - raw mode:   <stem>.aesbin (binary payload)
    if args.output:
        output_path = Path(args.output).resolve()
        if args.raw and output_path.suffix.lower() != ".aesbin":
            raise ValueError("When using --raw, output file must have a .aesbin extension.")
    else:
        output_path = input_path.with_name(f"{input_path.stem}.aesbin" if args.raw else f"{input_path.stem}.aes")

    password = get_password(args.password, confirm=True)

    content = input_path.read_bytes()
    encrypted = encrypt_bytes(content, password)

    if args.raw:
        output_path.write_bytes(encrypted)
    else:
        output_path.write_text(encode_payload(encrypted), encoding="utf-8")

    print(f"\n[OK] Encrypted file saved: {output_path}")


def decrypt_file_flow(args):
    input_path = Path(args.input).resolve()
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")

    # Force output to be a .txt file (because encrypt-file only allows .txt inputs).
    if args.output:
        output_path = Path(args.output).resolve()
        if output_path.suffix.lower() != ".txt":
            output_path = output_path.with_suffix(".txt") if output_path.suffix else Path(str(output_path) + ".txt")
    else:
        output_path = Path(str(input_path) + ".decrypted.txt")

    password = get_password(args.password, confirm=False)

    # Raw input is supported via --raw or by using the .aesbin extension.
    raw_in = bool(getattr(args, "raw", False)) or input_path.suffix.lower() == ".aesbin"
    if raw_in:
        payload = input_path.read_bytes()
    else:
        token = input_path.read_text(encoding="utf-8").strip()
        payload = decode_payload(token)

    plaintext = decrypt_bytes(payload, password)

    try:
        text_out = plaintext.decode("utf-8")
    except UnicodeDecodeError as exc:
        raise ValueError("Decrypted content is not valid UTF-8 text.") from exc

    output_path.write_text(text_out, encoding="utf-8")

    print(f"\n[OK] Decrypted file saved: {output_path}")


def encrypt_file_pem_flow(args):
    input_path = Path(args.input).resolve()
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")
    if not input_path.is_file():
        raise ValueError(f"Input path is not a file: {input_path}")

    public_key = load_public_key_pem(args.public_key)

    # Output rules:
    # - default: *_pem.aes (token/base64 text)
    # - with --raw: *_pem.aesbin (raw binary payload)
    if args.raw:
        default_out = input_path.with_name(f"{input_path.stem}_pem.aesbin")
        output_path = Path(args.output).resolve() if args.output else default_out
        if output_path.suffix.lower() != ".aesbin":
            raise ValueError("When using --raw, output file must have a .aesbin extension.")
    else:
        default_out = input_path.with_name(f"{input_path.stem}_pem.aes")
        output_path = Path(args.output).resolve() if args.output else default_out

    content = input_path.read_bytes()
    encrypted = encrypt_bytes_v4(content, public_key)

    if args.raw:
        output_path.write_bytes(encrypted)
    else:
        output_path.write_text(encode_payload(encrypted), encoding="utf-8")

    print(f"[OK] Encrypted file saved: {output_path}")


def decrypt_file_pem_flow(args):
    input_path = Path(args.input).resolve()
    if not input_path.exists():
        raise FileNotFoundError(f"Input file not found: {input_path}")
    if not input_path.is_file():
        raise ValueError(f"Input path is not a file: {input_path}")

    output_path = Path(args.output).resolve() if args.output else Path(str(input_path) + ".decrypted")
    private_key = load_private_key_pem(args.private_key, args.private_pass)

    is_raw = bool(args.raw) or input_path.suffix.lower() == ".aesbin"

    if is_raw:
        payload = input_path.read_bytes()
    else:
        token = input_path.read_text(encoding="utf-8").strip()
        payload = decode_payload(token)

    plaintext = decrypt_bytes_v4(payload, private_key)
    output_path.write_bytes(plaintext)

    print(f"[OK] Decrypted file saved: {output_path}")


def build_parser():
    parser = argparse.ArgumentParser(
        prog="aes256-cli",
        description="Secure AES-256 CLI encryption/decryption for text and .txt files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=HELP_EXAMPLES,
    )

    subparsers = parser.add_subparsers(dest="command")

    p_help = subparsers.add_parser("help", help="Show help and examples")
    p_help.set_defaults(func=help_flow, parser=parser)

    password_help = "Password text or .txt password file (if omitted, prompt securely)"

    p_enc_text = subparsers.add_parser("encrypt-text", help="Encrypt a text string")
    p_enc_text.add_argument("-t", "--text", help="Text to encrypt")
    p_enc_text.add_argument("-p", "--password", help=password_help)
    p_enc_text.set_defaults(func=encrypt_text_flow)

    p_dec_text = subparsers.add_parser("decrypt-text", help="Decrypt a text token")
    p_dec_text.add_argument("-t", "--token", help="Encrypted token")
    p_dec_text.add_argument("-p", "--password", help=password_help)
    p_dec_text.set_defaults(func=decrypt_text_flow)

    p_enc_file = subparsers.add_parser("encrypt-file", help="Encrypt a .txt file")
    p_enc_file.add_argument("-i", "--input", required=True, help="Input .txt file path")
    p_enc_file.add_argument("-o", "--output", help="Output encrypted file path (default: <stem>.aes or <stem>.aesbin when --raw)")
    p_enc_file.add_argument("--raw", action="store_true", help="Write raw binary payload instead of a base64 token file")
    p_enc_file.add_argument("-p", "--password", help=password_help)
    p_enc_file.set_defaults(func=encrypt_file_flow)

    p_dec_file = subparsers.add_parser("decrypt-file", help="Decrypt an encrypted file")
    p_dec_file.add_argument("-i", "--input", required=True, help="Input encrypted file path")
    p_dec_file.add_argument("-o", "--output", help="Output decrypted .txt file path (forced to .txt; default: input.decrypted.txt)")
    p_dec_file.add_argument("--raw", action="store_true", help="Read raw binary payload (or use .aesbin extension)")
    p_dec_file.add_argument("-p", "--password", help=password_help)
    p_dec_file.set_defaults(func=decrypt_file_flow)

    p_gen_keys = subparsers.add_parser("generate-keypair", help="Generate RSA private/public .pem files")
    p_gen_keys.add_argument(
        "--private-out",
        help="Private key output base path (timestamp DDMMYYYY_HHMMSS is always appended)",
    )
    p_gen_keys.add_argument(
        "--public-out",
        help="Public key output base path (timestamp DDMMYYYY_HHMMSS is always appended)",
    )
    p_gen_keys.add_argument("--bits", type=int, choices=[2048, 3072, 4096], default=4096, help="RSA key size")
    p_gen_keys.add_argument(
        "--private-pass",
        help="Password text or .txt file to encrypt private key PEM (optional)",
    )
    p_gen_keys.add_argument(
        "--encrypt-private",
        action="store_true",
        help="Prompt for private key password and encrypt private key PEM",
    )
    p_gen_keys.add_argument("--force", action="store_true", help="Overwrite key files if they already exist")
    p_gen_keys.set_defaults(func=generate_keypair_flow)

    private_key_pass_help = "Private key password text or .txt file (if key is encrypted)"

    p_enc_text_pem = subparsers.add_parser("encrypt-text-pem", help="Encrypt text with RSA public key (.pem)")
    p_enc_text_pem.add_argument("-t", "--text", help="Text to encrypt")
    p_enc_text_pem.add_argument("--public-key", required=True, help="Public key PEM path")
    p_enc_text_pem.set_defaults(func=encrypt_text_pem_flow)

    p_dec_text_pem = subparsers.add_parser("decrypt-text-pem", help="Decrypt text token with RSA private key (.pem)")
    p_dec_text_pem.add_argument("-t", "--token", help="Encrypted token")
    p_dec_text_pem.add_argument("--private-key", required=True, help="Private key PEM path")
    p_dec_text_pem.add_argument("--private-pass", help=private_key_pass_help)
    p_dec_text_pem.set_defaults(func=decrypt_text_pem_flow)

    p_enc_file_pem = subparsers.add_parser("encrypt-file-pem", help="Encrypt a file with RSA public key (.pem)")
    p_enc_file_pem.add_argument("-i", "--input", required=True, help="Input file path")
    p_enc_file_pem.add_argument("-o", "--output", help="Output encrypted file path (default: *_pem.aes, or *_pem.aesbin with --raw)")
    p_enc_file_pem.add_argument("--public-key", required=True, help="Public key PEM path")
    p_enc_file_pem.add_argument("--raw", action="store_true", help="Write raw binary payload (.aesbin) instead of a base64 token file")
    p_enc_file_pem.set_defaults(func=encrypt_file_pem_flow)

    p_dec_file_pem = subparsers.add_parser("decrypt-file-pem", help="Decrypt a file with RSA private key (.pem)")
    p_dec_file_pem.add_argument("-i", "--input", required=True, help="Input encrypted file path")
    p_dec_file_pem.add_argument("-o", "--output", help="Output decrypted file path")
    p_dec_file_pem.add_argument("--private-key", required=True, help="Private key PEM path")
    p_dec_file_pem.add_argument("--private-pass", help=private_key_pass_help)
    p_dec_file_pem.add_argument("--raw", action="store_true", help="Read raw binary payload (.aesbin). Auto-detected by .aesbin extension.")
    p_dec_file_pem.set_defaults(func=decrypt_file_pem_flow)

    return parser


def run_command(parser: argparse.ArgumentParser, argv: list[str], interactive: bool) -> bool:
    try:
        args = parser.parse_args(argv)
    except SystemExit:
        return False

    if not hasattr(args, "func"):
        parser.print_help()
        return False

    args.func(args)
    return True


def interactive_shell(parser: argparse.ArgumentParser) -> None:
    last_result = ""

    while True:
        try:
            clear_screen()
            print_dashboard(last_result)
            line = input("Enter command > ").strip()
            if not line:
                continue

            argv = shlex.split(line)
            executed = run_command(parser, argv, interactive=True)
            if executed:
                last_result = "[OK] Command completed."
            else:
                last_result = "[INFO] See command help above."
            input("\nPress Enter to continue...")
        except KeyboardInterrupt:
            clear_screen()
            print("[EXIT] Stopped by user (Ctrl + C).")
            break
        except EOFError:
            clear_screen()
            print("[EXIT] End of input.")
            break
        except ValueError as exc:
            last_result = f"[ERROR] {format_error(exc)}"
        except Exception as exc:
            last_result = f"[ERROR] {format_error(exc)}"



def format_error(exc: Exception) -> str:
    # Provide user-friendly, non-leaky messages for common failures.
    if isinstance(exc, InvalidTag):
        return "Authentication failed: wrong password/key or the data is corrupted."
    if isinstance(exc, FileNotFoundError):
        return str(exc)
    if isinstance(exc, PermissionError):
        return f"Permission denied: {exc}"
    if isinstance(exc, ValueError):
        return str(exc)
    return str(exc)


def main():
    parser = build_parser()
    if len(sys.argv) > 1:
        try:
            run_command(parser, sys.argv[1:], interactive=False)
        except Exception as exc:
            print(f"\n[ERROR] {format_error(exc)}", file=sys.stderr)
            sys.exit(1)
    else:
        interactive_shell(parser)


if __name__ == "__main__":
    main()
